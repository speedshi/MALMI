#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 13 14:26:55 2021

@author: shipe
"""


import numpy as np
import gc


def stream_resampling(stream, sampling_rate=100.0):
    """
    To resample the input seismic data.
    Parameters
    ----------
    stream : obspy stream
        input seismic data.
    sampling_rate : float
        required sampling rate in Hz, default is 100 Hz.

    Returns
    -------
    stream : obspy stream
        output seismic data after resampling.
    
    """
    
    for tr in stream:
        if tr.stats.sampling_rate != sampling_rate:
            if (len(tr.data) > 10):
                # perform resampling
                try:
                    if tr.stats.sampling_rate > sampling_rate:
                        # need lowpass filter before resampling
                        tr.filter('lowpass',freq=0.5*sampling_rate,zerophase=True)
                    tr.resample(sampling_rate=sampling_rate)    
                except:
                    try:
                        tr.interpolate(sampling_rate, method="linear")
                    except:
                        stream.remove(tr)
            else:
                # remove the trave if it only contains too few data points
                stream.remove(tr)
    
    return stream


def maxP2Stt(db_path, hdr_filename, model, precision):
    """
    This function is used to find the maximum traveltime difference between 
    P-phase and S-phase in the imaging area.

    Parameters
    ----------
    db_path : str
        path to travetime data set.
    hdr_filename : str
        header filename of the travetime data set.
    model : str
        traveltime data set filename tage, traveltime data are generated by 
        NonLinLoc software, so the same naming rules applied.
    precision : str
        persicion for traveltime data set, can be 'single' or 'double'.

    Returns
    -------
    tt_psmax : float
        the maximal arrivaltime difference bewteen S-phase and P-phase among 
        all stations in second for all imaging points.
        tt_psmax = max_{all imaging points}(max_{all station}(S_arrt) - min_{all stations}(P_arrt))
    tt_ppmax: fload
        the maximal arrivaltime difference bewteen P-phase among all stations 
        in second for all imaging points.
        tt_ppmax = max_{all imaging points}(max_{all station}(P_arrt) - min_{all stations}(P_arrt)) 
    tt_psmax_ss: float
        the maximal arrivaltime difference between S-phase and P-phase for 
        a perticular station in second for all imaging points.
        tt_psmax_ss = max_{all imaging points, all stations}(S_arrt - P_arrt)
    
    """
    
    from loki import traveltimes
    
    # load traveltime data set-------------------------------------------------
    tobj = traveltimes.Traveltimes(db_path, hdr_filename)
    tp = tobj.load_traveltimes('P', model, precision)  # P-wave traveltime table
    ts = tobj.load_traveltimes('S', model, precision)  # S-wave traveltime table
    
    stations = list(tobj.db_stations)  # station name list
    nstation = len(stations)  # total number of stations
    nxyz= np.size(tp[stations[0]])  # total number of imaging points
    tp_mod=np.zeros([nxyz, nstation])
    ts_mod=np.zeros([nxyz, nstation])
    for i, sta in enumerate(stations):
        tp_mod[:,i]=tp[sta]
        ts_mod[:,i]=ts[sta]
    
    del tp, ts
    
    tt_psmax_ss = np.amax(ts_mod - tp_mod, axis=None)
    
    tp_redmin = np.amin(tp_mod, axis=1)  # minimal P-wave traveltimes over different stations at each imaging point
    tp_redmax = np.amax(tp_mod, axis=1)  # maximal P-wave traveltimes over different stations at each imaging point
    ts_redmax = np.amax(ts_mod, axis=1)  # maximal S-wave traveltimes over different stations at each imaging point 
    
    del tp_mod, ts_mod
    
    tt_psmax = np.amax(ts_redmax - tp_redmin)  # maximal P to S arrivaltime difference over different stations in second among all imaging points
    tt_ppmax = np.amax(tp_redmax - tp_redmin)  # maximal P to P arrivaltime difference over different stations in second among all imaging points
    
    gc.collect()
    return tt_psmax, tt_ppmax, tt_psmax_ss


def dnormlz(data,n1=0,n2=1,axis=0):
    """
    This function is used to linearly normalize the data to the specified range.
    
    Parameters
    ----------
        data : data to be normalized;
        n1, n2 : the specified range;
        axis : on which axis of the data to perform normalization, None for flatten array;
    
    Returns
    -------
        data : normalized data, dimension is the same as input data.
    """
    
    dmax=np.max(data,axis=axis,keepdims=True)
    dmin=np.min(data,axis=axis,keepdims=True)
    
    k=(n2-n1)/(dmax-dmin)
    b=(dmax*n1-dmin*n2)/(dmax-dmin)
    
    data=k*data+b
    
    return data


def get_lokicoord(dir_tt, hdr_filename='header.hdr', extr=0.05, consider_mgregion=True):
    """
    This function is used to get the coordinates of station, plotting region
    and migration region from traveltime table data set of LOKI.

    Parameters
    ----------
    dir_tt : str
        path to the travetime data directory of LOKI.
    hdr_filename : str, optional
        travetime data set header filename. The default is 'header.hdr'.
    extr : float, optional
        extend ratio for automatically get the plotting region. 
        The default is 0.05.

    Returns
    -------
    inv : obspy invertory format
        station inventory containing station metadata.
    region : list of float
        the lat/lon boundary of plotting region, in format of 
        [lon_min, lon_max, lat_min, lat_max] in degree.
    mgregion : list of float
        the lat/lon boundary of migration region, in format of 
        [lon_min, lon_max, lat_min, lat_max] in degree.
    consider_mgregion : boolen
        indicate whether consider 'mgregion' when calculating 'region'.
    
    """
    
    from loki import traveltimes
    from obspy.core.inventory import Inventory, Network, Station
    from loki import LatLongUTMconversion
    
    # load station metadata from traveltime table data set
    tobj = traveltimes.Traveltimes(dir_tt, hdr_filename)
    station_name = []  # station name
    station_lon = []  # station longitude in degree
    station_lat = []  # station latitude in degree
    station_ele = []  # station elevation in km
    for staname in tobj.db_stations:
        station_name.append(staname)
        station_lat.append(tobj.stations_coordinates[staname][0])
        station_lon.append(tobj.stations_coordinates[staname][1])
        station_ele.append(tobj.stations_coordinates[staname][2])
    
    # create an obspy invertory according to station information
    inv = Inventory(networks=[], source="MALMI_LOKI_tt")
    net = Network(code="XX", stations=[], description="Tempory network generated by MALMI.")
    for ista in range(len(station_name)):
        sta = Station(code=station_name[ista], latitude=station_lat[ista],
                      longitude=station_lon[ista], elevation=station_ele[ista]*1000)  # note elevation need to transfer to meter
        net.stations.append(sta)
    inv.networks.append(net)
    
    # determine the lon/lat of migration area
    refell=23
    (UTMZone, eorig, norig) = LatLongUTMconversion.LLtoUTM(refell, tobj.lat0, tobj.lon0)  # the Cartesian coordinate of the origin point in meter
    elast_m = tobj.x[-1]*1000.0  # the East coordinate (X) of the last point for the migration area in meter
    nlast_m = tobj.y[-1]*1000.0  # the North coordinate (Y) of the last point for the migration area in meter
    late_last, lone_last = LatLongUTMconversion.UTMtoLL(refell, nlast_m+norig, elast_m+eorig, UTMZone)  # latitude, longitude
    mgregion = []
    mgregion.append(min(lone_last, tobj.lon0))
    mgregion.append(max(lone_last, tobj.lon0))
    mgregion.append(min(late_last, tobj.lat0))
    mgregion.append(max(late_last, tobj.lat0))
    
    # determine the lon/lat for plotting the basemap
    if consider_mgregion:
        lon_min = min(np.min(station_lon), mgregion[0])
        lon_max = max(np.max(station_lon), mgregion[1])
        lat_min = min(np.min(station_lat), mgregion[2])
        lat_max = max(np.max(station_lat), mgregion[3])
    else:
        lon_min = np.min(station_lon)
        lon_max = np.max(station_lon)
        lat_min = np.min(station_lat)
        lat_max = np.max(station_lat)
    region = [lon_min-extr*(lon_max-lon_min), lon_max+extr*(lon_max-lon_min),
              lat_min-extr*(lat_max-lat_min), lat_max+extr*(lat_max-lat_min)]
    
    return inv, region, mgregion



def catalog_select(catalog, thrd_cmax=None, thrd_stanum=None, thrd_phsnum=None, thrd_lat=None, thrd_lon=None, thrd_cstd=None):
    """
    This function is used to select events according to input criterions.

    Parameters
    ----------
    catalog : dic
        The input catalog which contains information of each event therein.
        mcatalog['id'] : id of the event;
        mcatalog['time'] : origin time;
        mcatalog['latitude'] : latitude in degree;
        mcatalog['longitude'] : logitude in degree;
        mcatalog['depth_km'] : depth in km;
        mcatalog['coherence_max'] : maximum coherence of migration volume;
        mcatalog['coherence_std'] : standard deviation of migration volume;
        mcatalog['coherence_med'] : median coherence of migration volume;
        mcatalog['starttime'] : detected starttime of the event;
        mcatalog['endtime'] : detected endtime of the event;
        mcatalog['station_num'] : total number of stations triggered of the event;
        mcatalog['phase_num'] : total number of phases triggered of the event;
        mcatalog['dir'] : directory of the migration results of the event.
    thrd_cmax : float, optional
        threshold of minimal coherence. The default is None.
    thrd_stanum : int, optional
        threshold of minimal number of triggered stations. The default is None.
    thrd_phsnum : int, optional
        threshold of minimal number of triggered phases. The default is None.
    thrd_lat : list of float, optional
        threshold of latitude range. The default is None.
    thrd_lon : list of float, optional
        threshold of longitude range. The default is None.
    thrd_cstd: float, optional
        threshold of maximum standard variance of stacking volume. The default is None.

    Returns
    -------
    catalog_s : dic
        The catalog containing the selected events.

    """
    
    n_event = len(catalog['time'])  # total number of event in the input catalog
    
    # select events according to the stacking coherence
    if thrd_cmax is not None:
        sindx = (catalog['coherence_max'] >= thrd_cmax)
    else:
        sindx = np.full((n_event,), True)
    
    # select events according to total number of triggered stations
    if thrd_stanum is not None:
        sindx_temp = (catalog['station_num'] >= thrd_stanum)
        sindx = np.logical_and(sindx, sindx_temp)
    
    # select events according to total number of triggered phases
    if thrd_phsnum is not None:
        sindx_temp = (catalog['phase_num'] >= thrd_phsnum)
        sindx = np.logical_and(sindx, sindx_temp)
    
    # select events according to latitude range
    if thrd_lat is not None:
        sindx_temp = (catalog['latitude'] >= thrd_lat[0]) & (catalog['latitude'] <= thrd_lat[1])
        sindx = np.logical_and(sindx, sindx_temp)
    
    # select events according to longitude range
    if thrd_lon is not None:
        sindx_temp = (catalog['longitude'] >= thrd_lon[0]) & (catalog['longitude'] <= thrd_lon[1])
        sindx = np.logical_and(sindx, sindx_temp)
        
    # select events according to standard variance of stacking volume
    if thrd_cstd is not None:
        sindx_temp = (catalog['coherence_std'] <= thrd_cstd)
        sindx = np.logical_and(sindx, sindx_temp)
    
    catalog_s = {}
    catalog_s['id'] = catalog['id'][sindx]
    catalog_s['time'] = catalog['time'][sindx]
    catalog_s['latitude'] = catalog['latitude'][sindx]
    catalog_s['longitude'] = catalog['longitude'][sindx]
    catalog_s['depth_km'] = catalog['depth_km'][sindx]
    catalog_s['coherence_max'] = catalog['coherence_max'][sindx]
    catalog_s['coherence_std'] = catalog['coherence_std'][sindx]
    catalog_s['coherence_med'] = catalog['coherence_med'][sindx]
    catalog_s['starttime'] = catalog['starttime'][sindx]
    catalog_s['endtime'] = catalog['endtime'][sindx]
    catalog_s['station_num'] = catalog['station_num'][sindx]
    catalog_s['phase_num'] = catalog['phase_num'][sindx]
    catalog_s['dir'] = catalog['dir'][sindx]
    
    return catalog_s