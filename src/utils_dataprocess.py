#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 13 14:26:55 2021

@author: shipe
"""


import numpy as np
import gc


def stream_resampling(stream, sampling_rate=100.0):
    """
    To resample the input seismic data.
    Parameters
    ----------
    stream : obspy stream
        input seismic data.
    sampling_rate : float
        required sampling rate in Hz, default is 100 Hz.

    Returns
    -------
    stream : obspy stream
        output seismic data after resampling.
    
    """
    
    for tr in stream:
        if tr.stats.sampling_rate != sampling_rate:
            # perform resampling
            try:
                if tr.stats.sampling_rate > sampling_rate:
                    # need lowpass filter before resampling
                    tr.filter('lowpass',freq=0.5*sampling_rate,zerophase=True)
                tr.resample(sampling_rate=sampling_rate)    
            except Exception:
                tr.interpolate(sampling_rate, method="linear")
    
    return stream


def maxP2Stt(db_path, hdr_filename, model, precision):
    """
    This function is used to find the maximum traveltime difference between 
    P-phase and S-phase in the imaging area.

    Parameters
    ----------
    db_path : str
        path to travetime data set.
    hdr_filename : str
        header filename of the travetime data set.
    model : str
        traveltime data set filename tage, traveltime data are generated by 
        NonLinLoc software, so the same naming rules applied.
    precision : str
        persicion for traveltime data set, can be 'single' or 'double'.

    Returns
    -------
    tt_psmax : float
        the maximal arrivaltime difference bewteen S-phase and P-phase among 
        all stations in second for all imaging points.
        tt_psmax = max_{all imaging points}(max_{all station}(S_arrt) - min_{all stations}(P_arrt))
    tt_ppmax: fload
        the maximal arrivaltime difference bewteen P-phase among all stations 
        in second for all imaging points.
        tt_ppmax = max_{all imaging points}(max_{all station}(P_arrt) - min_{all stations}(P_arrt)) 
    tt_psmax_ss: float
        the maximal arrivaltime difference between S-phase and P-phase for 
        a perticular station in second for all imaging points.
        tt_psmax_ss = max_{all imaging points, all stations}(S_arrt - P_arrt)
    
    """
    
    from loki import traveltimes
    
    # load traveltime data set-------------------------------------------------
    tobj = traveltimes.Traveltimes(db_path, hdr_filename)
    tp = tobj.load_traveltimes('P', model, precision)  # P-wave traveltime table
    ts = tobj.load_traveltimes('S', model, precision)  # S-wave traveltime table
    
    stations = list(tobj.db_stations)  # station name list
    nstation = len(stations)  # total number of stations
    nxyz= np.size(tp[stations[0]])  # total number of imaging points
    tp_mod=np.zeros([nxyz, nstation])
    ts_mod=np.zeros([nxyz, nstation])
    for i, sta in enumerate(stations):
        tp_mod[:,i]=tp[sta]
        ts_mod[:,i]=ts[sta]
    
    del tp, ts
    
    tt_psmax_ss = np.amax(ts_mod - tp_mod, axis=None)
    
    tp_redmin = np.amin(tp_mod, axis=1)  # minimal P-wave traveltimes over different stations at each imaging point
    tp_redmax = np.amax(tp_mod, axis=1)  # maximal P-wave traveltimes over different stations at each imaging point
    ts_redmax = np.amax(ts_mod, axis=1)  # maximal S-wave traveltimes over different stations at each imaging point 
    
    del tp_mod, ts_mod
    
    tt_psmax = np.amax(ts_redmax - tp_redmin)  # maximal P to S arrivaltime difference over different stations in second among all imaging points
    tt_ppmax = np.amax(tp_redmax - tp_redmin)  # maximal P to P arrivaltime difference over different stations in second among all imaging points
    
    gc.collect()
    return tt_psmax, tt_ppmax, tt_psmax_ss


def dnormlz(data,n1=0,n2=1,axis=0):
    """
    This function is used to linearly normalize the data to the specified range.
    
    Parameters
    ----------
        data : data to be normalized;
        n1, n2 : the specified range;
        axis : on which axis of the data to perform normalization, None for flatten array;
    
    Returns
    -------
        data : normalized data, dimension is the same as input data.
    """
    
    dmax=np.max(data,axis=axis,keepdims=True)
    dmin=np.min(data,axis=axis,keepdims=True)
    
    k=(n2-n1)/(dmax-dmin)
    b=(dmax*n1-dmin*n2)/(dmax-dmin)
    
    data=k*data+b
    
    return data


def get_lokicoord(dir_tt, hdr_filename='header.hdr', extr=0.05, consider_mgregion=True):
    """
    This function is used to get the coordinates of station, plotting region
    and migration region from traveltime table data set of LOKI.

    Parameters
    ----------
    dir_tt : str
        path to the travetime data directory of LOKI.
    hdr_filename : str, optional
        travetime data set header filename. The default is 'header.hdr'.
    extr : float, optional
        extend ratio for automatically get the plotting region. 
        The default is 0.05.

    Returns
    -------
    inv : obspy invertory format
        station inventory containing station metadata.
    region : list of float
        the lat/lon boundary of plotting region, in format of 
        [lon_min, lon_max, lat_min, lat_max] in degree.
    mgregion : list of float
        the lat/lon boundary of migration region, in format of 
        [lon_min, lon_max, lat_min, lat_max] in degree.
    consider_mgregion : boolen
        indicate whether consider 'mgregion' when calculating 'region'.
    
    """
    
    from loki import traveltimes
    from obspy.core.inventory import Inventory, Network, Station
    from loki import LatLongUTMconversion
    
    # load station metadata from traveltime table data set
    tobj = traveltimes.Traveltimes(dir_tt, hdr_filename)
    station_name = []  # station name
    station_lon = []  # station longitude in degree
    station_lat = []  # station latitude in degree
    station_ele = []  # station elevation in km
    for staname in tobj.db_stations:
        station_name.append(staname)
        station_lat.append(tobj.stations_coordinates[staname][0])
        station_lon.append(tobj.stations_coordinates[staname][1])
        station_ele.append(tobj.stations_coordinates[staname][2])
    
    # create an obspy invertory according to station information
    inv = Inventory(networks=[], source="MALMI_LOKI_tt")
    net = Network(code="XX", stations=[], description="Tempory network generated by MALMI.")
    for ista in range(len(station_name)):
        sta = Station(code=station_name[ista], latitude=station_lat[ista],
                      longitude=station_lon[ista], elevation=station_ele[ista]*1000)  # note elevation need to transfer to meter
        net.stations.append(sta)
    inv.networks.append(net)
    
    # determine the lon/lat of migration area
    refell=23
    (UTMZone, eorig, norig) = LatLongUTMconversion.LLtoUTM(refell, tobj.lat0, tobj.lon0)  # the Cartesian coordinate of the origin point in meter
    elast_m = tobj.x[-1]*1000.0  # the East coordinate (X) of the last point for the migration area in meter
    nlast_m = tobj.y[-1]*1000.0  # the North coordinate (Y) of the last point for the migration area in meter
    late_last, lone_last = LatLongUTMconversion.UTMtoLL(refell, nlast_m+norig, elast_m+eorig, UTMZone)  # latitude, longitude
    mgregion = []
    mgregion.append(min(lone_last, tobj.lon0))
    mgregion.append(max(lone_last, tobj.lon0))
    mgregion.append(min(late_last, tobj.lat0))
    mgregion.append(max(late_last, tobj.lat0))
    
    # determine the lon/lat for plotting the basemap
    if consider_mgregion:
        lon_min = min(np.min(station_lon), mgregion[0])
        lon_max = max(np.max(station_lon), mgregion[1])
        lat_min = min(np.min(station_lat), mgregion[2])
        lat_max = max(np.max(station_lat), mgregion[3])
    else:
        lon_min = np.min(station_lon)
        lon_max = np.max(station_lon)
        lat_min = np.min(station_lat)
        lat_max = np.max(station_lat)
    region = [lon_min-extr*(lon_max-lon_min), lon_max+extr*(lon_max-lon_min),
              lat_min-extr*(lat_max-lat_min), lat_max+extr*(lat_max-lat_min)]
    
    return inv, region, mgregion


